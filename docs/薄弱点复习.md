# 面试薄弱点复习

> 自测发现的薄弱环节，需要重点加强记忆

---

## 📅 2026-01-17 自测记录

### ⚠️ 需要加强的知识点

| 题目 | 薄弱点 | 正确答案 | 参考位置 |
|------|--------|----------|----------|
| ACID 四特性 | 英文单词没背熟 | Atomicity, Consistency, Isolation, Durability | `07-数据库与中间件.md` |
| 幻读 vs 不可重复读 | 理解有偏差 | 不可重复读=UPDATE改值，幻读=INSERT/DELETE改行数 | `07-数据库与中间件.md` |
| MVCC | 材料原无，已补充 | 多版本并发控制，读写不阻塞 | `07-数据库与中间件.md` |
| TIME_WAIT 2MSL | 原因不熟 | 确保ACK到达 + 等旧包消失 | `08-网络与操作系统.md` |
| 内存分配 vs GC | 概念混淆 | TCMalloc是分配，三色标记是GC | `04-Go底层原理.md` |
| 301 vs 302 | 材料原无，已补充 | 301永久缓存，302临时不缓存 | `08-网络与操作系统.md` |
| HTTPS 握手 | 材料原无，已补充 | 非对称换密钥，对称传数据 | `08-网络与操作系统.md` |

### ✅ 已掌握的知识点

- B+ 树 vs B 树原理
- 最左前缀原则
- 三次握手每一步的作用
- 四次挥手变三次的条件
- 三色标记法
- sync.Pool 适用场景
- 缓存穿透/击穿/雪崩

---

## 📅 2026-01-19 自测记录

### ⚠️ 需要加强的知识点

| 题目 | 薄弱点 | 正确答案 |
|------|--------|----------|
| 无缓冲 Channel | 误认为能正常输出 | 会死锁！发送阻塞等接收者 |
| HTTP 301/302 场景 | 应用场景不准确 | 301=换域名，302=登录跳转 |
| 联合索引范围查询 | 漏了范围查询后失效 | `b > 2` 后的 c 列无法用索引 |
| 脏读定义 | 需要看提示 | 读到别人未提交的数据 |

### 🔥 重点薄弱：无缓冲 Channel

```go
// ❌ 死锁！主 goroutine 自己发送，没人接收
func main() {
    ch := make(chan int)  // 无缓冲
    ch <- 1               // 阻塞在这里，永远等待
    fmt.Println(<-ch)     // 永远执行不到
}

// ✅ 方法1：另开 goroutine 发送
func main() {
    ch := make(chan int)
    go func() { ch <- 1 }()  // 另一个 goroutine 发送
    fmt.Println(<-ch)        // 主 goroutine 接收
}

// ✅ 方法2：用缓冲 channel
func main() {
    ch := make(chan int, 1)  // 容量为1
    ch <- 1                  // 不阻塞，放入缓冲区
    fmt.Println(<-ch)        // 从缓冲区取出
}
```

**记忆口诀**：
> "无缓冲 channel = 同步通信，必须有人接才能发"

### 🔥 重点薄弱：联合索引范围查询

```sql
-- 联合索引 (a, b, c)
WHERE a = 1 AND b > 2 AND c = 3

-- 只能用到 a 和 b！
-- 因为 b 是范围查询（>），之后的 c 失效
```

**记忆口诀**：
> "等值往后传，范围就断链"

---

## � 2026-01-19 下午自测记录

### ⚠️ 需要加强的知识点

| 题目 | 薄弱点 | 正确答案 |
|------|--------|----------|
| RDB 丢数据计算 | 算术错误 | 10:00保存，10:09断电 = 丢**9分钟**（不是10分钟） |
| 覆盖索引判断 | 漏选了 SELECT id | 非聚簇索引叶子节点**包含主键ID**，查ID也不回表 |
| Context.WithValue 的 key | 不确定为什么不能用 string | 防止包冲突，必须用**私有 struct 类型** |
| Slice 扩容陷阱 | 理解错误 | 扩容=断开共享，不扩容=互相影响 |

### 🔥 重点薄弱：Slice 扩容与底层数组共享

```go
// 场景1：容量不够，触发扩容
s1 := []int{1, 2, 3}       // len=3, cap=3
s2 := s1[1:]               // s2=[2,3], len=2, cap=2
s2 = append(s2, 4)         // cap不够，扩容！新数组！
// 结果：s1 还是 [1,2,3]，s2 变成 [2,3,4]
// ✅ 扩容后，s1 和 s2 不再共享底层数组

// 场景2：容量够，原地修改
s1 := make([]int, 3, 10)   // len=3, cap=10
s1[0], s1[1], s1[2] = 1, 2, 3
s2 := s1[1:]               // s2=[2,3], len=2, cap=9
s2 = append(s2, 4)         // cap够，原地写！
// 结果：底层数组变成 [1,2,3,4,...]
// ⚠️ s1 的 len 还是 3，看到的是 [1,2,3]
// ⚠️ 但 s1[:4] 会看到 [1,2,3,4]！
```

**记忆口诀**：
> "切片共享底层，扩容才断开。容量够就原地改，小心被偷家。"

### 🔥 重点薄弱：Context.WithValue 的 key

```go
// ❌ 错误：用 string 当 key
ctx = context.WithValue(ctx, "user_id", 123)
// 如果两个库都用了 "user_id"，就会冲突覆盖！

// ✅ 正确：用私有 struct 类型当 key
type userIDKey struct{}
ctx = context.WithValue(ctx, userIDKey{}, 123)
// 类型不同，永远不会冲突
```

**记忆口诀**：
> "Context key 用私有 struct，类型隔离不冲突。"

---

## �📝 复习口诀

### ACID 记忆

```
A - Atomicity   - 全有全无
C - Consistency - 账不能平不了
I - Isolation   - 各干各的
D - Durability  - 掉电不丢
```

### 幻读 vs 不可重复读

```
不可重复读：数据被改了（UPDATE）
幻读：凭空多/少了（INSERT/DELETE）
```

### TIME_WAIT 2MSL

```
1MSL 去 + 1MSL 回 = 2MSL
- 确保最后ACK能到
- 让旧包消失干净
```

### HTTPS 握手

```
非对称换钥匙（慢但安全）
对称传数据（快）
```

---

> 💡 建议：面试前重点复习本文档标记的薄弱点！

---

## 📋 橙享共享厨房速记（Java 项目，简答即可）

> 面试 Go 岗位，这个项目不是重点。如果问到，简单带过：

**一句话介绍**：
> "这是毕设项目，用 Spring Boot 做的物联网共享厨房平台。"

**三个技术点（被追问时用）**：

1. **MQTT**：设备接入协议，比 HTTP 轮询省电省流量
2. **TCC**：Try 冻结余额 → Confirm 扣款 → Cancel 回滚
3. **Redis+RabbitMQ**：缓存热点 + 削峰填谷
